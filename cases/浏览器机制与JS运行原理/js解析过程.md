# js解析过程

## js解析过程

对于静态语言(Java、C++、C等)来说，有一个“编译器”，可以将写好的代码编译成另一种代码(如机器码,字节码)，
然后通过其它方法(比如汇编器转换汇编代码)将这些机器码变为机器可执行命令，这就是大致的代码运行过程。
而对于Javascript这样一种动态语言而言，有一个“解释器”，
可以直接动态解析代码，并将代码运行，输出结果。
你知道JS代码解析运行的流程么，请描述出来?

```js
如果一个文档流中包含多个Script代码段(用Script标签分隔的js代码或引入的js文件),他们的执行顺序是:

步骤1:读入第一个代码段(JS执行引擎并非一行一行的执行程序,而是一段一段的分析)
步骤2:做语法分析,有错则报语法错误(比如括号不匹配),并调到步骤5
步骤3:对var变量和function做’预解析’(先进行函数声明，而后进行变量声明（如果已经有函数声明，则变量声明无效），变量统一的默认值是undefined,)
步骤4:执行代码段(赋值也是在这个阶段),有错则报错(比如调用了null.属性就会报错)
步骤5:如果还有下一个代码段,则读入下一个代码段,重复步骤2
步骤6:结束
```

## JS变量声明，形参，函数声明的顺序与优先级?

填充变量的顺序：

函数形参 -> 函数声明 -> 变量声明
当变量声明遇到VO中已有同名时，不会影响已经存在的属性

函数形参：
由名称和对应值组成的一个变量对象的属性被创建
没有传对应参数的话，那么由名称和undefined组成的变量对象的属性会被创建

函数声明：
由名称和对应值（函数对象(function-object)）组成一个变量对象的属性会被创建
如果变量中已经有这个相同名称的属性，则完全替换

变量声明：
由名称和对应值（undefined）组成的一个变量对象的属性被创建
如果变量名称与已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的

## JS中var声明变量和绑定到window上的区别？

```js
var a = 1;

window.a = 1;
```

这两者有区别么？

**有区别**

虽然说乍看之下没区别，都能正常使用，但实际上从概念上来说要区分，
为了简单，以下只介绍`VO(globalContext)`

1. `var a = 1;`

    - 如果有这个语句，那么在进入这个执行上下文时，`VO(globalContext)`就已经有了属性`a`了
    
    - 就算是`let`也一样，有let声明，VO(globalContext)就会有这个属性，只不过直到`let`声明语句时这个属性才可用（所以let不存在hoist）
    
2. `window.a = 1;`

    - 如果有这个语句，那么在进入这个执行上下文时，`VO(globalContext)`**不会有属性`a`**
    
    - 直到执行到`window.a = 1;`时，才会在global中加入这个属性
    
而在函数作用域中，差别更甚

而之所以在全局作用域中，这两个看起来相等，是因为`VO(globalContext) === global`

## JS中VO和AO的区别

变量对象VO是与执行上下文相关的特殊对象,用来存储上下文的函数声明，函数形参和变量。

在global全局上下文中，变量对象也是全局对象自身，在函数上下文中，变量对象被表示为活动对象AO。

```js
VO(globalContext) === global
```

在函数执行上下文中，**VO是不能直接访问的**，此时由活动对象(activation object,缩写为AO)扮演VO的角色。

```js
VO(functionContext) === AO;
```

所以，这两者完全可以理解是同一个东西，只不过由于某些细微功能区别，分出了两个概念而已

## this与执行上下文

this是执行上下文中的一个属性：（和VO类似）

```js
activeExecutionContext = {
  VO: {...},
  this: thisValue,
  scopeChain: ...（还有一个作用域链，这里省略）,
};
```

**this与上下文中可执行代码的类型有直接关系，this值在进入上下文时确定，并且在上下文运行期间永久不变。**

所以，在全局代码中，this始终是全局对象本身，这样就有可能间接的引用到它了。

## 从JS的词法分析到AO

从解释器分析词法，到AO的生成（以函数作用域为例）

关键步骤：

1. 先分析参数

2. 分析函数声明（优先级高于变量提升）

3. 分析变量声明

步骤：

1. 函数的在进入可执行上下文的瞬间，生成一个活动对象（Active Object)就是所谓的AO

2. 分析参数

    - 函数接收参数（型参），添加到AO的属性上面，值全部都是undefined,如AO.age=undefined
    
    - 接收实参，形成AO对应的属性值
    
3. 分析函数的声明，如果funcion foo(){}

    - 如果AO中已经有这个变量，会覆盖，因此AO.foo为这个函数
    
4. 分析变量声明，如var age,

    - 如果AO上还没有age属性，则添加AO 属性，值是undefined
    
    - 如果AO 上面已经有了age属性,则不做任何操作。
    
5. 接下来就是其它的正常语句执行，变量赋值

关于函数声明和变量声明的先后参考来源：在《你不知道的JavaScript（上卷）》一书的第4章节中写到：**函数会首先被提升，然后才是变量。**

简单理解：函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖

不过，你会发现，假设你理解的是，先变量提升，再函数声明，由于函数声明会覆盖变量，所以可能从代码角度上无法直接检测到区别。
（这里就先依参考来源中的概念来构建了）

### 执行栈的简单解释

进一步展开（这部分包含执行上下文概念，不理解可以先跳过）

- JS有一个`执行栈`）

- 浏览器首次载入脚本，它将创建`全局执行上下文`，并压入执行栈栈顶（不可被弹出）

- 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部

- 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。

- 这样依次执行（最终都会回到全局执行上下文）