# 内存回收

##  js的内存回收机制

1.标记清除
主流浏览器实现的垃圾清除机制，最常用的垃圾回收方式

当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
而当变量离开环境时，则将其标记为“离开环境”。

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

2.引用计数
需要考虑循环引用问题

引用计数的含义是跟踪记录每个值被引用的次数。
当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
如果同一个值又被赋给另一个变量，则该值的引用次数加1。

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。
当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

但是需要考虑两个对象循环引用的问题，容易造成内存泄漏

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：
1）遍历所有可访问的对象。
2）回收已不可访问的对象。

GC的缺陷
和其他语言一样，javascript的GC策略也无法避免一个问题：
GC时，停止响应其他操作，这是为了安全考虑。
而Javascript的GC在100ms甚至以上，对一般的应用还好，
但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。
这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

GC优化策略
1.分代回收（Generation GC）
目的是通过区分“临时”与“持久”对象；
多回收“临时对象”区（young generation），
少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

2.增量GC
这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。
这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。

比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。

像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）

## 那些操作会造成内存泄漏？

垃圾收回机制会找出不使用的变量（周期性，间隔性），并释放内存

但是如果这个变量引用被持有，则无法释放

一般：

全局变量没有用好会造成内存无法回收
闭包也很容易造成内存泄露
一些未清理的dom元素引用也易造成
或者被遗忘的定时器或回调
dom子字元素持有引用不置空也容易造成
带监听事件的dom元素被innerHTML替换后也可能会造成内存泄露

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
  闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）