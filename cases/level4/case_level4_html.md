# 难度等级4，难点或深度知识

## 介绍一下对浏览器内核的理解？

浏览器内核主要功能有两大块：

- 渲染引擎

- 脚本引擎

一般常规意义上的浏览器内核就值得是渲染引擎，JS脚本引擎大多都已经独立出去了（如Chrome的V8）

渲染内容：

```js
页面渲染包括把HTML文档转换成DOM树，并渲染成renderLayer之类的图层渲染到页面上，

同时渲染引擎还会根据css中的样式，对render图层进行一些修饰（如一些css属性）

另外，还有一块WebGl模块可以用GPU来绘制图形，一般可通过tree.js等第三方js库来绘制或者css开启硬件加速后也是默认GPU加速

渲染图层一般包含两类：
普通图层以及复合图层。

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能
但是尽量比较大了使用复合图层，否则由于资源消耗过度，页面反而会变的更卡
```

脚本引擎值浏览器读取JS，然后按照语法规则解析，并执行
一般浏览器中会提供一些API允许JS脚本进行一些DOM操作，并且也会内置一些BOM对象（如Navigator等）
脚本引擎也有它的进化史，从最初仅支持最简单的DOM操作逻辑，到后来独立后越来越复杂的ES5，ES6等语法

小结：

```js
JS引擎解析和执行JS来实现网页的动效，最开始渲染引擎和JS引擎并没有分开，后来JS引擎越来越独立，内核倾向于只渲染

渲染引擎负责取得网页的内容（HTML,XML，图像等），整理讯息（如css），以及计算网页的显示方式（render），输出至显示器
浏览器内核不同对网页的语法解析会不同，渲染效果也不同
```

## 常见的浏览器内核有哪些

一般分为几大阵营：

- `Trident`IE（7，8，9，...），号称自己都不兼容自己，好在移动端不需要兼容，而且其实到IE11时性能已经赶上去了，但无奈声名已狼藉

- `泛Webkit`内核（包括它的升级变种Blink），Chrome，Safari等现今主流浏览器都是基于这个或它的变种
这种内核对W3C标准支持的很好
    
- `Gecko`Firefox浏览器的内核，火狐的内核，虽然和Webkit有区别，但是W3C标准也支持的很好，如果使用标准的CSS等属性，几乎无需另外兼容

- 微软的新版浏览器，`Edge`,号称全面兼容webkit等内核的属性，作为新作，去除了历史兼容的包袱，应该也走在W3C标准支持的路上了

- 其它阵营，如opera等（以前是`Presto`），一般一些历史上层级采用IE内核的浏览器大多接近阵亡了（如世界之窗等），像opera等这种浏览器也开始采用webkit，往标准上靠

基本上，未来的趋势就是往W3C标准靠，然后各大浏览器在这基础上实现自己的特色

另外，有一点，Webkit内核并不是完全标准，里面有很多私有属性，但是它对标准的支持确实不错，
还有就是多个浏览器都采用了webkit，导致只需要兼容一个`-webkit-xxx`就可以兼容大多浏览器，
这使的开发者都普遍拥抱webkit内核的浏览器

番外，webkit是苹果开源的一个内核，Google在它基础上自己弄了一个chromium，然后chrome是基于chromium的，
所以一般很多人会直接把chrome代指webkit内核

## 前端需要注意那些seo?

```html
<meta content="xxxx" name="keywords">
<meta content="xxx" name="description">
```

1.合理的title,description,keywords
引擎搜索对三项的权重逐渐减小，
title强调重点即可(重点关键词出现不要超过2次，而且要靠前)，不同页面title要不同
description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面的description要有所区分
keywords列举出重点关键词

2.语义化html，符合w3c规范，语义化让搜索引擎容易理解网页

3.重要的html内容放在最前方，搜索引擎抓取html顺序是从上到下，
有得搜索引擎长度有限制，因此要确保重要内容被抓取

4.重要内容不要用js输出（爬虫不会执行js获取内容）

5.避免iframe,爬虫不会抓取iframe中的内容

6.非装饰性图片必须加alt(图片无法显示时替代，图片内容的等价描述，读屏器会阅读图片，搜索引擎重点分析)

7.提高网站访问速度，网站速度是搜索引擎排序的一个重要指标

## 谈谈src与href的区别？

- src用于替换当前的元素，href在当前文档和引用资源之间确立关系

src是source的缩写，指向外部资源的位置，指向的内容会嵌入到当前文档中当前标签所在位置，

```html
<img src ='xxx.jpg'/>
```

如，在请求上述src资源时，会将其指向的资源下载并应用到文档内（替换到原有的img标签位置）

- href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接

如果我们在文档中添加

```html
<link href='common.css' rel='stylesheet'/>
```

那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。

注意，如果css中有@import，它会等待页面加载完毕后再去加载样式，会造成页面无样式的尴尬情况

## src加载img和加载script的区别？

```html
<script src ='js.js'></script>
```

当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，这也是为什么将js脚本放在底部而不是头部。

```html
<img src ='xxx.jpg'/>
```
当浏览器解析到该元素时，并不会阻塞渲染，而是异步加载（src引用的图片等外部资源不会阻塞渲染）

因为：

- js脚本阻塞渲染并不是因为他是src引入的，而是因为他有可能改变DOM树或CSSOM树，所以遇到脚本会先下载并执行

## 浏览器渲染过程

浏览器渲染过程参考：

1、输入url发送请求

2、加载html文件

3、加载完后解析html，并在解析的过程中构建DOM树
解析遇到link、script、img标签时，浏览器会向服务器发送请求资源。
script的加载或者执行都会阻塞html解析、其他下载线程以及渲染线程。
link加载完css后会解析为CSSOM(层叠样式表对象模型,一棵仅含有样式信息的树)。css的加载和解析不会阻塞html的解析，但会阻塞渲染。
img的加载不会阻塞html的解析，但img加载后并不渲染，它需要等待Render Tree生成完后才和Render Tree一起渲染出来。未下载完的图片需等下载完后才渲染。

4、当css解析为CSSOM后，html解析为DOM后，两者将会结合在一起生成Render Tree(渲染树)。

5、Layout: 计算出Render Tree每个节点的具体位置。

6、Painting：通过显卡，将Layout后的节点内容(含已下载图片)分别呈现到屏幕上。
