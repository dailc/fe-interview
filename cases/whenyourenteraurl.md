# 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

## 参考来源

[http://www.cnblogs.com/iovec/p/7904416.html](http://www.cnblogs.com/iovec/p/7904416.html)

## 简洁题型版

注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，
而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、
到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

- 简洁版：

```js
1. 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；

2. 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；

3. 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；

4. 载入解析到的资源文件，渲染页面，完成。
```

- 完善版

```js
1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;

2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;

3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;

4、进行HTTP协议会话，客户端发送报头(请求报头);

5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;

6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;

7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;

8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;

9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;

10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。
```

## 详细解析版

### 简述

从输入网址，到网页展示，一般包括两大类步骤:

-  网络通信

- 页面渲染

__网络通信__

1.DNS解析成IP地址

2.发送http请求

3.tcp报文传输

4.ip寻址

5.封装成帧

6.物理传输

__网页渲染__

1.页面渲染主流程

2.dom树和render树的关系

3.布局render树（layout）

4.绘制（paint）

__五层因特网协议栈（osi标准七层模型，但是实际实现通常是五层）__

1.应用层(dns,http) DNS解析成IP并发送http请求

2.传输层(tcp,udp) 建立tcp连接（三次握手）

3.网络层(IP,ARP) IP寻址

4.数据链路层(PPP) 封装成帧

5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

__OSI七层框架:__

- 包括： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

```js
表示层：主要用于处理两个通信系统中交换信息的表示方式，为上层用户解决用户信息的语法问题
包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

会话层：在两个节点间建立端连接，为端系统的应用程序之间提供对话控制机制。
会话层管理登陆和注销过程，它具体管理两个用户和进程之间的对话，
如果某时某刻只允许一个用户执行一项特定操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一数据
```

### DNS解析成IP地址

dns属于应用层协议，客户端会先检查本地是否有缓存（浏览器缓存，本机缓存，host），如果有就返回，否则请求上级dns服务器，直到找到根结点（这一过程可能会很耗时）

所以有一些公司会用 `dns-prefetch`来使得浏览器在空闲时间提前将这些域名转换为ip地址，请求资源时避免这一时间
注意，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS预读取能节省每月100亿的DNS查询 。
如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：

```html
meta http-equiv="x-dns-prefetch-control" content="off"
```

### 发送http请求

http也是应用层协议，是基于请求／响应模式的，无状态的应用层协议，用于从万维网服务器传输超文本到本地浏览器

客户端发送的http报文包括:method,url,host，头部域（包括cookie），实体域等信息

### 传输层：tcp传输报文

tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输

__连接时的三次握手__

```js
客户端发送一个TCP的syn=1，seq number=X的包到服务器端
服务器发回syn=1，ack number=X+1, ack=1，seq number=Y的响应包
客户端发送ack number=Y+1，ack=1，seq number=Z

服务器检测到syn=1后就直到了客户端的建立联机请求
客户端会检测ack number是否为第一次发送的seq number+1以及ack是否为1
服务端也会检测ack num和发送的匹配

SYN(synchronous建立联机)
ACK(acknowledgement 确认)
Sequence number(顺序号码)

通俗点:
客户端：hello，我要和server通信
服务端：hello，我是server，你是client么
客户端：yes，我是client

建立连接成功后，接下来就正式传输数据
```

__tcp断开时有四次挥手__

```js
主动方发送fin=1，seq=X
被动方发送ack number=X+1，seq=Y2
被动方发送fin=1，seq=Y
主动方发送ack number=Y+1，seq=X2

FIN(finish结束) 
RST(reset重置)
URG(urgent紧急)
PSH(push传送) 

通俗点：
主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
被动方：收到通道关闭的信息
被动方：那我也告诉你，我这边向你的主动通道也关闭了
主动方：最后收到数据，之后双方无法通信
```

__需要注意的是：__

浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）

所以针对这个瓶颈，又出现了很多的资源优化方案

```js
资源打包，合并请求（减少css,js，资源等请求数量）
域名拆分，资源分散存储（主域名下有各种资源部署的子域名）
Connection: keep-alive，复用已建立的连接（现在基本都是，早期时每完成一个请求就会关闭，重复建立非常浪费资源）
控制缓存（将资源缓存到客户端，减少请求数）
延迟加载，懒加载，按需加载（主要是首屏去除优先级较低的请求）
```

### 网络层: ip寻址

Internet Protocol 是定义网络之间彼此互联规则的协议，主要解决逻辑寻址和网络通用数据传输格式两个问题

```js
每一个连接因特网的设备都会被分配一个IP，虽然每一个设备的ip可以更换，
但是mac硬件地址一般不变，所以需要使用ARP 协议来找到目标主机的mac硬件地址
当通信双方不在同一网段时，需要多次中转（路由）才能找到最终目标
在中转过程还有可能需要通过下一个中转站的mac硬件地址来搜索下一个中转目标

传输层的tcp报文会在这一层被IP封装成网络通用数据格式：ip数据包
ip数据包是真正在网络间进行传输的数据基本单位

通过逻辑寻址定位到应用层DNs解析出来的IP地址的主机网络位置，
然后把数据以IP数据包的格式发送到那去
```

### 数据链路层：封装成帧

数据链路层将iP数据包封装成适合在物理网络上传输的帧格式并传输

```js
数据链路层的主要目的是在原始的，有差错的物理传输路线基础上，
采取差错检测，差错控制和流量控制等方法，
将有差错的物理路线改进成逻辑上无差错的数据链路，
向网络层提供高质量的服务。

当采用复用技术时，一条物理链路上可以有多条数据链路
```

### 物理层：物理传输

上面这么多层其实都是对要传输对数据进行处理，
而物理层则是通过各种介质（双绞线，电磁波，光纤等）以信号的形式将封装好的数据物理传送出去

然后漂洋过海，达到另一台主机的物理层

接着又开始从物理层往上，一层一层解封，最终应用层拿到数据后解析

解析完后，服务端开始响应，一样的步骤，只不过这次起点是服务器，然后消息到达客户端后，客户端解析出来，开始准备页面渲染（还有一个检测过程）

__客户端处理报文__

```js
如果返回304（如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304），代表目前的缓存未过期，使用缓存
否则浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
开始建立文档树，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
```

### 页面渲染主流程

渲染引擎在取得内容后的基本流程如下

- 解析html建立dom树

- 解析css构建render树

- 布局render树

- 绘制render树

```js
浏览器首先开始解析html，并将标签转换为dom树中的dom节点
接着，它解析外部css及style标签中的样式信息，
这些信息以及html标签中的可见指令将被用来构建另一棵树-render树

render树构建好了后，将会执行布局过程，该过程将会确定render树每一个节点在屏幕上的确切目标，
最后是绘制render树，即遍历render树的每一个节点并将它们绘制到屏幕上
关键: DOM tree + StyleRules = Render Tree(layout)

为了更好的用户体验，渲染引擎将会尽可能早的将内容绘制到屏幕上，
而不是等到所有的html解析完后再去构建，布局和绘制，它是解析完一部分就绘制一部分内容
同时可能还通过网络下载其余内容（图片，脚本，样式）

譬如，浏览器在代码中发现一个img标签引用了一张图片，于是向服务端发出图片请求，
此时浏览器不会等等图片下载完，而是会继续解析渲染页面后面的内容，
等到服务器返回图片文件，而由于图片占有一定的面积，影响了后面段落的布局，于是浏览器会回过头来重新渲染这部分内容
```

### dom树和render树的关系

render树节点和dom树节点相对应，但这种对应关系不是一对一的。

不可见的dom元素不会被插入render树，例如head元素、script元素等。
另外，display属性为none的元素也不会在渲染树中出现
（visibility属性为hidden的元素将出现在渲染树中，这是因为visibility属性为hidden的元素虽然不可见但保留了元素的占位）。

### 布局render树(layout)

```js
当渲染对象被创建并添加到render树后，它们并没有位置和大小，计算这些值的过程称为layout（布局）

布局的坐标系统相对于根渲染对象（对于html标签，可以用document.documentElement拿到）
使用top和left坐标，跟渲染对象的位置是(0,0)，它的大小是viewport（即浏览器窗口的可见部分）

布局是一个递归过程，由根渲染对象开始，然后递归的通过一些或所有的层级节点，为每个需要几何信息的渲染对象进行计算
为了避免每一个小变化都全部重新布局，浏览器使用一个 dirty bit（页面重写标识位）系统，
一个渲染对象发生了变化，或是被添加了，就标记它的children为dirty（需要layout）

当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：

- 一个全局的样式改变影响所有的渲染对象（譬如字号的改变）

- 窗口resize

layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局），
增量layout会在渲染对象dirty时异步触发，
例如，当网络接收到新的内容并添加到dom树后，新的渲染对象会添加到render树中。
```

### 绘制(paint)

```js
绘制阶段，遍历render树，并调用渲染对象的paint方法，将它们的内容显示在屏幕上，
和布局一样，绘制也是可以全局（绘制完整的树）或增量的，
在增量的绘制过程中，一些渲染对象不影响整棵树的方式改变，
改变的渲染对象使其在屏幕上的矩形区域失效(invalidate)，
这将导致操作系统将其看成dirty区域，并产生一个paint事件，
操作系统很巧妙的处理这个过程，并将多个区域合并成一个

浏览器总是试图以最小的动作响应一个变化，所以一个元素的颜色变化只会导致该元素的重绘，
元素的位置变化将会导致元素的布局与重绘，添加一个dom节点，也会导致这个元素的布局和重绘。

一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而导致整个render树的布局和重绘

重绘完毕后，页面就已经成功展示了
```