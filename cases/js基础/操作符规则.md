# 操作符规则

## `<,>,<=,>=`的比较规则

所以比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下：

1.如果操作数是对象，转为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错

2.经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字符串顺序进行比较（它们的16位unicode值的大小）
注意，不是字母表中的位置，是编码，譬如B的编码是66，a的编码是97，所以B < a

3.否则，如果有一个操作数不是字符串，将两个操作数转位数字进行比较

4.NaN与任何结果比较都返回false

## ==运算符判断相等的流程是怎样的

1.如果两个值类型相同，按照===比较方法进行比较

2.如果类型不同，使用如下规则进行比较

3.如果其中一个值是null，另一个是undefined，它们相等

4.如果一个值是数字另一个是字符串，将字符串转换为数字进行比较

5.如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较

6.如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较

7.其他所有情况都认为不相等
譬如NaN与任何数都不相等包括它本身
undefined和null两者都与0是不相等的

## ===运算符判断相等的流程是怎样的

1.如果两个值不是相同类型，它们不相等

2.如果两个值都是null或者都是undefined，它们相等

3.如果两个值都是布尔类型true或者都是false，它们相等

4.如果其中有一个是NaN，它们不相等

5.如果都是数值型并且数值相等，他们相等， -0等于0

6.如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等;
如果在长度或者内容上不等，它们不相等；
两个字符串显示结果相同但是编码不同==和===都认为他们不相等

7.如果他们指向相同对象、数组、函数，它们相等；
如果指向不同对象，他们不相等

## ,号操作符

```js
var num = (5, 1, 4, 3, 2); // num的值为2
```

逗号操作符总会返回表达式中最后一项

## ~~和Math.floor()的区别

首先，两者都能实现的功能就是：取整

如

```js
~~1.1; // 1
Math.floor(1.1); // 1
```

区别在于：
javascript内部的数值默认按IEEE-754 64位格式存储

而~~属于位操作，位操作只会在32位上进行，所以会将值先转位32位，执行完操作后再转回去
而Math.floor是直接在64位上操作

所以说，两者的适合精度不一样，Math.floor更通用，但是~~效率更高

## !运算符的工作流程

这是逻辑非操作

1.如果操作数是一个对象，返回false

2.如果操作对象是一个空字符串，返回true

3.如果操作对象是一个非空字符串，返回false

4.如果操作对象是0，返回true

5.如果操作对象是非0数值（包括Infinity），返回false

6.如果操作对象是NaN，返回true

7.如果操作对象是null，返回true

8.如果操作对象是undefined，返回true

### ++和--运算符的工作流程

数值的或直接++或--，其它的

1.如果应用对象是一个包含有效数字的字符串时，会先将其转换为数字，然后++或--，字符串变数值

2.如果不包含有效数字，将变量的值设置为NaN，字符串变数值

3.如果是false，先变为0，然后++或--，布尔变数值

4.如果是true，先变为1，然后++或--，布尔变数值

5.如果是浮点数字，直接++或--

6.应用于对象，先调用对象的valueOf()以取得一个可操作的值，按照前述规则解析，如果是NaN，继续调用toString()，
继续前述规则解析，对象变数值

## +和-运算符的工作流程

该操作符会像Number()一样对值进行转换

1.false,true-0,1

2.字符串按照特殊规则解析

3.对象先调用valueOf()，如果非法则调用toString()

## *运算符工作流程

1.如果操作符都是数值，执行常规的乘法操作，即正负得负，负负得正，
如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity

2.如果有一个操作数是NaN，则结果是NaN

3.如果是Infinity与0相乘，结果是NaN

4.如果是Infinity与非0相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号。

5.如果是Infinity与Infinity相乘，则结果是Infinity

6.如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用到上面的规则

## /运算符工作流程

1.如果操作符都是数值，执行常规的除法操作，
如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity

2.如果有一个操作数是NaN，则结果是NaN

3.如果是Infinity被Infinit除，结果是NaN

4.如果是零被零除，则结果是NaN

5.如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号

6.如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。

7.如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用于上面的规则。

## 求模运算符工作流程

1.如果两个操作符都是数值，执行常规的除法计算，返回除得的余数

2.如果被除数是无穷大值而除数是有限大的数值，返回NaN

3.被除数是有限大的值，而除数是零，则结果是NaN

4.如果是Infinity被Infinity除，则结果是NaN

5.被除数是有限大的数值而除数是无穷大的数值，则结果是被除数。

6.如果被除数是零，则结果是零

7.如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用于上面的我规则

## 加性操作符工作流程

1.如果有一个操作数是NaN，则结果是NaN

2.如果是Infinity加Infinity，结果是Infinity

3.如果是-Infinity加-Infinity，结果是-Infinity

4.如果是Infinity加-Infinity，结果是NaN

5.如果是+0加+0，结果是+0

6.如果是-0加-0，结果是-0

7.如果是+0加-0，结果是+0

不过，如果有一个操作符是字符串，则运用一下规则

1.如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接

2.如果只有一个操作数是字符串，则将另一个操作数转为字符串，然后两个操作数拼接

3.如果有一个操作数是对象，数值或布尔，则调用它们的toString()方法获取相应的字符串值，然后再应用前面关于字符串的规则，
对于undefined和null，分别调用String()函数并取得字符串'undefined'和'null'

注意：

```js
'1' + 2 + 3; // 结果是123
```

## 减性操作符工作流程

1.如果两个操作符都是数值，则执行常规的算数操作符并返回结果

2.如果有一个操作符是NaN，返回NaN

3.如果是Infinity减Infinity，结果是NaN

4.如果是-Infinity减-Infinity，结果是NaN

5.如果是Infinity减-Infinity，结果是Infinity

6.如果是-Infinity减Infinity，结果是-Infinity

7.如果是+0减+0，结果是+0

8.如果是-0减+0，结果是-0

9.如果是-0减-0，结果是+0

10.如果有一个操作符是字符串，布尔值，undefined或null，则在后台先调用Number()转为数值，
然后再根据前面的规则执行减法计算，
如果转换结果是NaN，则减法结果是NaN

11.如果有一个操作符是对象，则调用对象的valueOf()获取改对象的值，如果得到NaN，
那么结果是NaN，
如果对象没有valueOf()，则调用toString()并转为数值

## 连等号赋值顺序

注意，**不推荐使用连等赋值**

```js
var a = {n: 1}
var b = a;
a.x = a = {n: 2}
console.log(a); // {n: 2}
console.log(a.x); // undefined
console.log(b); // {n: 1, x: {n: 2}}
console.log(b.x) // {n: 2}
```

因为连等号这个语句中会**先确定所有遍历的指针**，然后才会去对于赋值

其中

```js
a.x = a = {n: 2} 
```

- 指针确定如下
a.x的指针已经确定了，指向了原始a的（因为原始a没有x，因此创建了一个指向null的指针）
a指向也是原始a

- 赋值如下
a重新指向到了新的地址 {n: 2}（栈中的指针指向了堆中新的对象）
原始a.x的指向到了 {n: 2}

- 因此最后
a指向到了新的{n: 2}
a.x为undefined

b指向原始a
b.x = {n: 2}

简单的理解，因为js中是值传递模式，所以在连等开始赋值之前，以及分别有`a.x`和`a`这两个指针的值的。
最初时，`a`和`a.x`分别指向堆内存中的`{n: 1, x: null}`以及里面的`x`。
然后赋值阶段，`a`重新换了一个指向，指向了`{n: 2}`，而`a.x`仍然是原始的a（也就是和另一个备份的`b`指向一样）

## 为什么说+拼接字符串效率低

因为js中，字符串是原始值，创建后是无法更改的（栈内存中）

```js
var lang = 'hello';

lang = lang + ' world';
```

1.变量lang开始时包含字符串'hello'

2.第二行代码把'hello'重新定义为'hello'与' world'的组合

实现这个操作的过程如下：
1.首先创建一个新的字符串（容纳组合的所有字符）
2.然后这个字符串填充'hello'与' world'的组合
3.销毁原来的字符串'hello'与' world'（因为这两个字符串已经没用了）

这也是为什么某些旧版浏览器字符串拼接时速度很慢

不过，一般新版的浏览器中已经修复了这个问题，当然了，一般情况下我们还是会避免代码拼接字符串的

## Object.is与原来的比较操作符 ===， ==的区别？

ES6才新增
两等号判等，会在比较时进行类型转换；
三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；

Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，
但 Object.is(NaN, NaN) 会返回 true.

Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。